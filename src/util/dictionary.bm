$Debug
'dictionary.bm - dictionary library
'create and use dictionaries (collections of key-value pairs) (sometimes called maps)
'keys may be long or string
'values may be long, string, or double

$Asserts
Option _Explicit
''$Include: 'list.bi'
''$Include: 'variant.bm'
''$include: 'dictionary.bi'

Const DICT_NONE = 0
Const DICT_KSTR_VSTR = 1
Const DICT_KSTR_VLNG = 2
Const DICT_KSTR_VDBL = 3
Const DICT_KLNG_VSTR = 4
Const DICT_KLNG_VLNG = 5
Const DICT_KLNG_VDBL = 6

Type DictHolderStruct
    dictHandle As Long
    dictName As String
    dictType As _Byte
    dictKeyElemSize As _Byte
    dictValElemSize As _Byte
    dictMemKeys As _MEM
    dictMemVals As _MEM
    dictAlloc As Long
    dictLength As Long 'elements used, from 0..ListAlloc
    'dictMaxLength As Long
    dictGrowth As Single '1.0 = 100% - amount to expand when realloc()ing
End Type

ReDim Shared DictStore(1 To 10) As DictHolderStruct
Dim Shared As Long DictMaxUsed, DictReleased, DictLastHandle


''' (re)initialize the dictionary library
Sub DictInit
    ReDim DictStore(1 To 10) As DictHolderStruct
    DictMaxUsed = 0
    DictReleased = 0
End Sub

''' shut down the dictionary library, freeing all resources and invalidating dictionary instances
Sub DictTerminate
    DictReleaseAll
End Sub

''' free the dictionary from memory, invalidating dictHandle
Sub DictRelease (dictHandle As Long)
    If dictHandle = 0 Then Exit Sub
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    _Assert dictIndex > 0, "Dictionary handle not found"
    If dictIndex = 0 Then Exit Sub
    DictReleaseAt dictIndex, _TRUE
End Sub

''' free the dictionary from memory, invalidating its dictHandle value
Sub DictReleaseAt (dictIndex As Long, autoCompact As _Byte)
    Dim dict As DictHolderStruct
    dict = DictStore(dictIndex)
    _Assert dict.dictType <> DICT_NONE, "Invalid dictionary type"
    If dict.dictHandle = 0 Or dict.dictType = DICT_NONE Then Exit Sub
    If _MemExists(dict.dictMemKeys) Then
        _MemFree dict.dictMemKeys
    End If
    If _MemExists(dict.dictMemVals) Then
        _MemFree dict.dictMemVals
    End If
    ' Select Case DictStore(dictIndex).dictType
    '     Case DICT_KSTR_VSTR
    '     Case DICT_KSTR_VLNG
    '     Case DICT_KSTR_VDBL
    '     Case DICT_KLNG_VSTR
    '     Case DICT_KLNG_VLNG
    '     Case DICT_KLNG_VDBL
    '     '     Dim i As Long
    '     '     Dim m As _MEM, elem As Long
    '     '     m = _Mem(elem)
    '     '     For i = 1 To LstStore(lstIndex).listLength
    '     '         _MemCopy LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.OFFSET + _SIZE_OF_LONG * (i - 1), _SIZE_OF_LONG To m, m.OFFSET
    '     '         VTRelease elem
    '     '     Next i
    '     '     _MemFree m
    '     '     _MemFree LstStore(lstIndex).listMeM
    '     ' Case LST_LONG
    '     '     _MemFree LstStore(lstIndex).listMeM
    '     ' Case LST_DOUBLE
    '     '     _MemFree LstStore(lstIndex).listMeM
    ' End Select
    DictStore(dictIndex).dictHandle = 0
    DictStore(dictIndex).dictName = ""
    DictStore(dictIndex).dictType = DICT_NONE
    DictReleased = DictReleased + 1
    Dim ub As Long
    ub = UBound(DictStore)
    If autoCompact _AndAlso ub > 10 _AndAlso DictMaxUsed - DictReleased < ub * 0.4 Then
        DictCompact ub \ 2
    End If
End Sub

Sub DictReleaseAll
    Dim i As Long
    For i = 1 To DictMaxUsed
        DictReleaseAt (i), _FALSE
    Next i
    ReDim DictStore(1 To 10) As DictHolderStruct
    DictMaxUsed = 0
    DictReleased = 0
End Sub

Function DictStoreIndexOf& (dictHandle As Long)
    'TODO: consider sorting DictStore by handle and using binary search
    Dim As Long i, rslt
    rslt = -1
    For i = 1 To DictMaxUsed
        If DictStore(i).dictHandle = dictHandle Then
            _Assert DictStore(i).dictType <> DICT_NONE, "Invalid dictionary type"
            rslt = i
            Exit For
        End If
    Next i
    DictStoreIndexOf = rslt
End Function

Function DictNewKStrVStr&
    Dim dictIndex As Long
    dictIndex = DictCreate(DICT_KSTR_VSTR, 10, 1.0, _SIZE_OF_LONG, _SIZE_OF_LONG) 'each string is saved as a long variant handle
    _Assert dictIndex > 0, "Dictionary creation failed"
    DictNewKStrVStr = DictStore(dictIndex).dictHandle
End Function

Function DictNewKStrVLng&
    Dim dictIndex As Long
    dictIndex = DictCreate(DICT_KSTR_VLNG, 10, 1.0, _SIZE_OF_LONG, _SIZE_OF_LONG) 'each string is saved as a long variant handle
    _Assert dictIndex > 0, "Dictionary creation failed"
    DictNewKStrVLng = DictStore(dictIndex).dictHandle
End Function

Function DictNewKStrVDbl&
    Dim dictIndex As Long
    dictIndex = DictCreate(DICT_KSTR_VDBL, 10, 1.0, _SIZE_OF_LONG, _SIZE_OF_DOUBLE) 'each string is saved as a long variant handle
    _Assert dictIndex > 0, "Dictionary creation failed"
    DictNewKStrVDbl = DictStore(dictIndex).dictHandle
End Function

Function DictNewKLngVStr&
    Dim dictIndex As Long
    dictIndex = DictCreate(DICT_KLNG_VSTR, 10, 1.0, _SIZE_OF_LONG, _SIZE_OF_LONG) 'each string is saved as a long variant handle
    _Assert dictIndex > 0, "Dictionary creation failed"
    DictNewKLngVStr = DictStore(dictIndex).dictHandle
End Function

Function DictNewKLngVLng&
    Dim dictIndex As Long
    dictIndex = DictCreate(DICT_KLNG_VLNG, 10, 1.0, _SIZE_OF_LONG, _SIZE_OF_LONG) 'each string is saved as a long variant handle
    _Assert dictIndex > 0, "Dictionary creation failed"
    DictNewKLngVLng = DictStore(dictIndex).dictHandle
End Function

Function DictNewKLngVDbl&
    Dim dictIndex As Long
    dictIndex = DictCreate(DICT_KLNG_VDBL, 10, 1.0, _SIZE_OF_LONG, _SIZE_OF_DOUBLE) 'each string is saved as a long variant handle
    _Assert dictIndex > 0, "Dictionary creation failed"
    DictNewKLngVDbl = DictStore(dictIndex).dictHandle
End Function

Function DictCreate (dictType As _Byte, initialSize As Long, growth As Single, keyElementSize As _Byte, valElementSize As _Byte)
    DictLastHandle = DictLastHandle + 1
    Dim dictIndex As Long
    dictIndex = DictNextStoreIndex
    DictStore(dictIndex).dictHandle = DictLastHandle
    DictStore(dictIndex).dictType = dictType
    DictStore(dictIndex).dictAlloc = initialSize 'array of 10 elements
    DictStore(dictIndex).dictGrowth = growth 'grow 100% when full
    DictStore(dictIndex).dictLength = 0
    DictStore(dictIndex).dictKeyElemSize = keyElementSize
    DictStore(dictIndex).dictValElemSize = valElementSize
    DictStore(dictIndex).dictMemKeys = _MemNew(DictStore(dictIndex).dictAlloc * keyElementSize)
    DictStore(dictIndex).dictMemVals = _MemNew(DictStore(dictIndex).dictAlloc * valElementSize)
    DictCreate = dictIndex
End Function

Function DictNextStoreIndex&
    Dim rslt As Long
    If DictReleased > 0 Then
        rslt = DictStoreIndexOf(0)
        _Assert rslt > 0, "Internal error, released list handle search failed."
        DictReleased = DictReleased - 1
    Else
        Do While DictMaxUsed >= UBound(DictStore)
            ReDim _Preserve DictStore(1 To 2 * UBound(DictStore)) As DictHolderStruct
        Loop
        DictMaxUsed = DictMaxUsed + 1
        rslt = DictMaxUsed
    End If
    DictNextStoreIndex = rslt
End Function

Sub DictAddKStrVStr (dictHandle As Long, ky As String, vl As String)
    _Assert dictHandle > 0, "Invalid list handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictAddKStrVStrAt dictIndex, ky, vl
End Sub

' Sub LstAddLng (lHandle As Long, n As Long)
'     _Assert lHandle > 0, "Invalid list handle arguement"
'     Dim lstIndex As Long
'     lstIndex = LstStoreIndexOf(lHandle)
'     LstAddLngAt lstIndex, n
' End Sub

' Sub LstAddDbl (lHandle As Long, n As Double)
'     _Assert lHandle > 0, "Invalid list handle arguement"
'     Dim lstIndex As Long
'     lstIndex = LstStoreIndexOf(lHandle)
'     LstAddDblAt lstIndex, n
' End Sub

Sub DictAddKStrVStrAt (dictIndex As Long, ky As String, vl As String)
    _Assert dictIndex > 0, "List handle not found"
    If dictIndex = 0 Then Exit Sub

    'are we adding a new kv pair, or changing an existing kv pair?
    Dim keyIx As Long
    keyIx = DictFindKeySAt(dictIndex, ky)
    If keyIx > 0 Then
        'change value
    Else
        'add key and value
        'grow key and val arrays if needed
        If DictStore(dictIndex).dictLength + 1 > DictStore(dictIndex).dictAlloc Then
            DictGrowAt dictIndex
        End If
        DictStore(dictIndex).dictLength = DictStore(dictIndex).dictLength + 1
        keyIx = DictStore(dictIndex).dictLength
    End If
    'poke in new key, value at ends of arrays
    Dim m As _MEM
    Dim strvar As Long
    '!    strvar = VTNewStr(ky)
    m = _Mem(strvar)
    _MemCopy m, m.OFFSET, m.SIZE _ 
      To DictStore(dictIndex).dictMemKeys, DictStore(dictIndex).dictMemKeys.OFFSET + (keyix-1) * DictStore(dictIndex).dictKeyElemSize
    '!   strvar = VTNewStr(val)
    _MemCopy m, m.OFFSET, m.SIZE _ 
      To DictStore(dictIndex).dictMemVals, DictStore(dictIndex).dictMemVals.OFFSET + (keyix-1) * DictStore(dictIndex).dictValElemSize
    _MemFree m
    ' 'update list properties
End Sub

Function DictFindKeySAt& (dictIndex As Long, ky As String)
    'assume all params are valid
    Dim d As DictHolderStruct
    d = DictStore(dictIndex)
    Dim keys(1 To d.dictLength) As Long 'array of Variant-String
    Dim m As _MEM
    m = _Mem(keys())
    _MemCopy d.dictMemKeys, d.dictMemKeys.OFFSET, d.dictMemKeys.SIZE To m, m.OFFSET
    _MemFree m
    Dim As Long rslt, i
    rslt = 0
    For i = 1 To d.dictLength
        '!        if VTStr(keys(i)) = key Then
        rslt = i
        Exit For
        '!        endif
    Next i
    DictFindKeySAt = rslt
End Function

Function DictFindKeyLAt& (dictIndex As Long, ky As Long)
    'assume all params are valid
    Dim d As DictHolderStruct
    d = DictStore(dictIndex)
    Dim keys(1 To d.dictLength) As Long 'array of Variant-String
    Dim m As _MEM
    m = _Mem(keys())
    _MemCopy d.dictMemKeys, d.dictMemKeys.OFFSET, d.dictMemKeys.SIZE To m, m.OFFSET
    _MemFree m
    Dim As Long rslt, i
    rslt = 0
    For i = 1 To d.dictLength
        If keys(i) = ky Then
            rslt = i
            Exit For
        End If
    Next i
    DictFindKeyLAt = rslt
End Function

' Sub LstAddLngAt (lstIndex As Long, n As Long)
'     _Assert lstIndex > 0, "List handle not found"
'     'grow list if needed
'     If LstStore(lstIndex).listLength + 1 > LstStore(lstIndex).listAlloc Then
'         LstGrowAt (lstIndex)
'     End If
'     'poke in new value at end
'     Dim m As _MEM
'     m = _Mem(n)
'     _MemCopy m, m.OFFSET, m.SIZE To LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.OFFSET + LstStore(lstIndex).listLength * _SIZE_OF_LONG
'     _MemFree m
'     'update list properties
'     LstStore(lstIndex).listLength = LstStore(lstIndex).listLength + 1
' End Sub

' Sub LstAddDblAt (lstIndex As Long, n As Double)
'     _Assert lstIndex > 0, "List handle not found"
'     'grow list if needed
'     If LstStore(lstIndex).listLength + 1 > LstStore(lstIndex).listAlloc Then
'         LstGrowAt (lstIndex)
'     End If
'     'poke in new value at end
'     Dim m As _MEM
'     m = _Mem(n)
'     _MemCopy m, m.OFFSET, m.SIZE To LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.OFFSET + LstStore(lstIndex).listLength * _SIZE_OF_DOUBLE
'     _MemFree m
'     'update list properties
'     LstStore(lstIndex).listLength = LstStore(lstIndex).listLength + 1
' End Sub

Sub DictGrowAt (dictIndex As Long)
    Dim grow As Long
    grow = _Ceil(DictStore(dictIndex).dictAlloc * DictStore(dictIndex).dictGrowth)
    If grow < 1 Then grow = 1
    Dim m As _MEM
    m = _MemNew((DictStore(dictIndex).dictAlloc + grow) * DictStore(dictIndex).dictKeyElemSize)
    _MemCopy DictStore(dictIndex).dictMemKeys, DictStore(dictIndex).dictMemKeys.OFFSET, DictStore(dictIndex).dictLength * DictStore(dictIndex).dictKeyElemSize _
      To m, m.OFFSET
    _MemFree DictStore(dictIndex).dictMemKeys
    DictStore(dictIndex).dictMemKeys = m

    m = _MemNew((DictStore(dictIndex).dictAlloc + grow) * DictStore(dictIndex).dictValElemSize)
    _MemCopy DictStore(dictIndex).dictMemVals, DictStore(dictIndex).dictMemVals.OFFSET, DictStore(dictIndex).dictLength * DictStore(dictIndex).dictValElemSize _
      To m, m.OFFSET
    _MemFree DictStore(dictIndex).dictMemVals
    DictStore(dictIndex).dictMemVals = m

    DictStore(dictIndex).dictAlloc = DictStore(dictIndex).dictAlloc + grow
End Sub

Sub DictDelete (dictHandle As Long, position As Long)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictDeleteAt dictIndex, position, _TRUE
End Sub

Sub DictDeleteAt (dictIndex As Long, position As Long, autoCompact As _Byte)
    'delete elements at position from both dictMemKeys and dictMemVals arrays in DictStore(dictIndex)
    _Assert dictIndex > 0, "Dictionary handle not found"
    If position < 1 Or position > DictStore(dictIndex).dictLength Then Exit Sub 'invalid position
    'keys are all 32-bits
    If DictStore(dictIndex).dictType = DICT_KSTR_VSTR Or DictStore(dictIndex).dictType = DICT_KSTR_VLNG Or DictStore(dictIndex).dictType = DICT_KSTR_VDBL Then
        'key is variant-string, so get long handle and release it
        Dim m As _MEM
        Dim deleteVt As Long
        m = _Mem(deleteVt)
        _memcopy DictStore(dictIndex).dictMemKeys,DictStore(dictIndex).dictMemKeys.Offset + (position-1) * DictStore(dictIndex).dictKeyElemSize, m.size _ 
          To m, m.offset
        _MemFree m
        '!VTRelease deleteVt
        'delete key at position, move rest of array down 1 slot
        If position < DictStore(dictIndex).dictLength Then
            _memcopy DictStore(dictIndex).dictMemKeys, _
                     DictStore(dictIndex).dictMemKeys.Offset + position * DictStore(dictIndex).dictKeyElemSize, _
                     (DictStore(dictIndex).dictLength-Position) * DictStore(dictIndex).dictKeyElemSize _
                  To DictStore(dictIndex).dictMemKeys, _
                     DictStore(dictIndex).dictMemKeys.Offset + (position-1) * DictStore(dictIndex).dictKeyElemSize
        End If

        'if value is a variant, fetch value at position and release it
        If DictStore(dictIndex).dictType = DICT_KSTR_VSTR Or DictStore(dictIndex).dictType = DICT_KLNG_VSTR Then
            m = _Mem(deleteVt)
            _memcopy DictStore(dictIndex).dictMemVals, _
                     DictStore(dictIndex).dictMemVals.Offset + (position-1) * DictStore(dictIndex).dictValElemSize, _
                     DictStore(dictIndex).dictValElemSize _
                  To m, m.offset
            _MemFree m
            '!vtRelease deleteVt
        End If

        'delete value at position, move rest of array down 1 slot
        If position < DictStore(dictIndex).dictLength Then
            _memcopy DictStore(dictIndex).dictMemVals,DictStore(dictIndex).dictMemVals.Offset + position * DictStore(dictIndex).dictValElemSize, _
              (DictStore(dictIndex).dictLength-Position) * DictStore(dictIndex).dictValElemSize _
              To DictStore(dictIndex).dictMemVals,DictStore(dictIndex).dictMemVals.Offset + (position-1) * DictStore(dictIndex).dictValElemSize
        End If

        'shorten array usage 1 slot
        DictStore(dictIndex).dictLength = DictStore(dictIndex).dictLength - 1
    End If

    If autoCompact Then
        Dim newalloc As Long
        newalloc = DictStore(dictIndex).dictAlloc
        Do While DictStore(dictIndex).dictLength / (newalloc / (1 + DictStore(dictIndex).dictGrowth)) < 0.8
            newalloc = _Ceil((newalloc / (1 + DictStore(dictIndex).dictGrowth)) < 0.8)
        Loop
        If newalloc < 10 Then newalloc = 10
        If DictStore(dictIndex).dictAlloc <> newalloc Then
            'shrink keys
            m = _MemNew(newalloc * DictStore(dictIndex).dictKeyElemSize)
            _memcopy DictStore(dictIndex).dictMemKeys, DictStore(dictIndex).dictMemKeys.offset, DictStore(dictIndex).DictLength * DictStore(dictIndex).dictKeyElemSize _ 
              To m, m.Offset
            _MemFree DictStore(dictIndex).dictMemKeys
            DictStore(dictIndex).dictMemKeys = m

            'shrink vals
            m = _MemNew(newalloc * DictStore(dictIndex).dictValElemSize)
            _memcopy DictStore(dictIndex).dictMemVals, DictStore(dictIndex).dictMemVals.offset, DictStore(dictIndex).DictLength * DictStore(dictIndex).dictValElemSize _ 
              To m, m.Offset
            _MemFree DictStore(dictIndex).dictMemVals
            DictStore(dictIndex).dictMemVals = m
        End If
    End If
End Sub

Function DictLookupStrForLng$ (dictHandle As Long, ky As Long)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictLookupStrForLng = DictLookupStrForLngAt(dictIndex, ky)
End Function

Function DictLookupLngForLng& (dictHandle As Long, ky as Long)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictLookupLngForLng = DictLookupStrForLngAt(dictIndex, ky)
End Function

Function DictLookupDblForLng# (dictHandle As Long, ky as Long)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictLookupDblForLng = DictLookupStrForLngAt(dictIndex, ky)
End Function

Function DictLookupStrForStr$ (dictHandle As Long, ky as String)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictLookupStrForStr = DictLookupStrForStrAt(dictIndex, ky)
End Function

Function DictLookupLngForStr& (dictHandle As Long, ky as String)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictLookupLngForStr = DictLookupLngForStrAt(dictIndex, ky)
End Function

Function DictLookupDblForStr# (dictHandle As Long, ky as String)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    DictLookupDblForStr = DictLookupDblForStrAt(dictIndex, ky)
End Function

Function DictLookupStrForLngAt$(dictIndex as Long, ky as Long)
    Dim d As DictHolderStruct, rslt as string, m As _MEM, keys(1 To d.dictLength) As Long 'array of Variant-String
    d = DictStore(dictIndex)
    m = _Mem(keys())
    _MemCopy d.dictMemKeys, d.dictMemKeys.OFFSET, d.dictMemKeys.SIZE To m, m.OFFSET
    _MemFree m
    Dim As Long ix, i
    ix = 0
    For i = 1 To d.dictLength
        '!        if VTStr(keys(i)) = key Then ix = i: Exit For
    Next i
    DictLookupStrForLngAt = DictStrValAt(dictHandle as long, valIndex as Long)
End Function

Function DictStrValueAt$()
    dim rslt as string
    if ix = 0 Then
        rslt = ""
    Else 'fetch value
        dim rsltHandle as Long
        m = _mem(rsltHandle)
        _memcopy d.dictMemKeys, d.dictMemKeys.OFFSET + (ix - 1) * d.dictValElemSize, d.dictValElemSize To m, m.OFFSET
        memfree m
        rslt = VTStr(rsltHandle)
    endif
    DictStrValueAt = rslt
end function

Function DictLngValueAt$()
    dim rslt as Long
    if ix = 0 Then
        rslt = 0&
    Else 'fetch value
        m = _mem(rslt)
        _memcopy d.dictMemKeys, d.dictMemKeys.OFFSET + (ix - 1) * d.dictValElemSize, d.dictValElemSize To m, m.OFFSET
        memfree m
    endif
    DictStrValueAt = rslt
end function

Function DictDblValueAt$()
    dim rslt as Double
    if ix = 0 Then
        rslt = 0.0#
    Else 'fetch value
        m = _mem(rslt)
        _memcopy d.dictMemKeys, d.dictMemKeys.OFFSET + (ix - 1) * d.dictValElemSize, d.dictValElemSize To m, m.OFFSET
        memfree m
    endif
    DictStrValueAt = rslt
end function

' Function LstStrAtAtIndex$ (lstIndex As Long, position As Long)
'     _Assert lstIndex > 0, "List handle not found"
'     If position < 1 Or position > LstStore(lstIndex).listLength Then
'         LstStrAtAtIndex = ""
'         Exit Function
'     End If
'     Dim strvar As Long
'     Dim m As _MEM
'     m = _Mem(strvar)
'     _MemCopy LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.OFFSET + (position - 1) * _SIZE_OF_LONG, _SIZE_OF_LONG To m, m.OFFSET
'     _MemFree m
'     LstStrAtAtIndex = VTStr(strvar)
' End Function

' Function LstLngAtAtIndex& (lstIndex As Long, position As Long)
'     _Assert lstIndex > 0, "List handle not found"
'     If position < 1 Or position > LstStore(lstIndex).listLength Then
'         LstLngAtAtIndex = 0&
'         Exit Function
'     End If
'     Dim lngvar As Long
'     Dim m As _MEM
'     m = _Mem(lngvar)
'     _MemCopy LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.OFFSET + (position - 1) * _SIZE_OF_LONG, _SIZE_OF_LONG To m, m.OFFSET
'     _MemFree m
'     LstLngAtAtIndex = lngvar
' End Function

' Function LstDblAtAtIndex# (lstIndex As Long, position As Long)
'     _Assert lstIndex > 0, "List handle not found"
'     If position < 1 Or position > LstStore(lstIndex).listLength Then
'         LstDblAtAtIndex = 0.0#
'         Exit Function
'     End If
'     Dim dblvar As Double
'     Dim m As _MEM
'     m = _Mem(dblvar)
'     _MemCopy LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.OFFSET + (position - 1) * _SIZE_OF_DOUBLE, _SIZE_OF_DOUBLE To m, m.OFFSET
'     _MemFree m
'     LstDblAtAtIndex = dblvar
' End Function

Function DictCount& (dictHandle As Long)
    _Assert dictHandle > 0, "Invalid dictionary handle arguement"
    Dim dictIndex As Long
    dictIndex = DictStoreIndexOf(dictHandle)
    LstCount = LstCountAt(lstIndex)
End Function

Function LstCountAt& (lstIndex As Long)
    _Assert lstIndex > 0, "List handle not found"
    LstCountAt = LstStore(lstIndex).listLength
End Function


''' Redimension list store if <40% full (due to element deletions)
Sub DictCompact (newUB As Long) 'size in Long elements
    _Assert newUB > 10 And newUB * 0.8 > DictMaxUsed - DictReleased, "DictCompact upper bound too low."
    Dim As Long i, j, newmax
    If DictReleased > 0 Then
        j = 2
        For i = 1 To LstMaxUsed
            If LstStore(i).listHandle = 0 Then
                If j <= i Then j = i + 1
                Do While LstStore(j).listHandle = 0 And j < LstMaxUsed
                    j = j + 1
                Loop
                If j <= LstMaxUsed Then
                    LstStore(i) = LstStore(j)
                    LstStore(j).listHandle = 0
                    LstStore(j).listType = LST_NONE
                    LstStore(j).listName = ""
                    If LstStore(i).listHandle > 0 Then newmax = i
                End If
            Else
                newmax = i
            End If
        Next i
        LstMaxUsed = newmax
        LstReleased = 0
    End If
    ReDim _Preserve LstStore(1 To newUB) As LstHolderStruct
End Sub

''' Return a string representation of the list, such as:  ListOfString["apples", "oranges"] or ListOfLong[1,2,4,8]
Function LstToStr$ (lstHandle As Long)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lstIndex As Long
    lstIndex = LstStoreIndexOf(lstHandle)
    LstToStr = LstToStrAt(lstIndex)
End Function

Function LstToStrAt$ (lstIndex As Long)
    Dim rslt As String
    _Assert lstIndex > 0, "List handle not found"
    Dim lst As LstHolderStruct
    Dim i As Long, sep As String
    lst = LstStore(lstIndex)
    Select Case lst.listType
        Case LST_STRING
            rslt = "String List"
            If lst.listName <> "" Then rslt = rslt + " " + lst.listName
            sep = "["
            For i = 1 To lst.listLength
                rslt = rslt + sep + _CHR_QUOTE + LstStrAtAtIndex(lstIndex, i) + _CHR_QUOTE
                sep = ", "
            Next i
            rslt = rslt + "]"
        Case LST_LONG
            rslt = "Long List"
            If lst.listName <> "" Then rslt = rslt + " " + lst.listName
            sep = "["
            For i = 1 To lst.listLength
                rslt = rslt + sep + Str$(LstLngAtAtIndex(lstIndex, i))
                sep = ", "
            Next i
            rslt = rslt + "]"
        Case LST_DOUBLE
            rslt = "Double List"
            If lst.listName <> "" Then rslt = rslt + " " + lst.listName
            sep = "["
            For i = 1 To lst.listLength
                rslt = rslt + sep + Str$(LstDblAtAtIndex(lstIndex, i))
                sep = ", "
            Next i
            rslt = rslt + "]"
    End Select
    LstToStrAt = rslt
End Function

Sub LstDump
    Dim i As Long
    Dim listCount As Long
    Print "List Store"
    listCount = 0
    Print String$(80, Chr$(196))
    For i = 1 To LstMaxUsed
        Select Case LstStore(i).listType
            Case LST_STRING
                Print i; " "; LstToStrAt(i)
                listCount = listCount + 1
            Case LST_LONG
                Print i; " "; LstToStrAt(i)
                listCount = listCount + 1
            Case LST_DOUBLE
                Print i; " "; LstToStrAt(i)
                listCount = listCount + 1
        End Select
    Next i
    Print String$(80, Chr$(205))
    Print String$(50," "); listCount; " list(s)."
    Print
End Sub

Sub LstSetName (lstHandle As Long, newName As String)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lstIndex As Long
    lstIndex = LstStoreIndexOf(lstHandle)
    LstSetNameAt lstIndex, newName
End Sub

Sub LstSetNameAt (lstIndex As Long, newName As String)
    _Assert lstIndex > 0, "List handle not found"
    LstStore(lstIndex).listName = newName
End Sub

Function lstGetName$ (lstHandle As Long)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lstIndex As Long
    lstIndex = LstStoreIndexOf(lstHandle)
    lstGetName = lstGetNameAt(lstIndex)
End Function

Function lstGetNameAt$ (lstIndex As Long)
    _Assert lstIndex > 0, "List handle not found"
    lstGetNameAt = LstStore(lstIndex).listName
End Function

Sub LstSort (lstHandle As Long, ascending As _Byte)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lstIndex As Long
    lstIndex = LstStoreIndexOf(lstHandle)
    LstSortAt lstIndex, ascending
End Sub

Sub LstSortAt (lstIndex As Long, ascending As _Byte)
    _Assert lstIndex > 0, "List handle not found"
    Dim lLen As Long
    lLen = LstStore(lstIndex).listLength
    Dim m As _MEM
    Dim As Long i, j

    Select Case LstStore(lstIndex).listType
        Case LST_STRING
            ReDim aStrs(1 To lLen) As String
            ReDim aVars(1 To lLen) As Long
            m = _Mem(aVars())
        _memcopy LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.offset, m.size _
            To m, m.offset
            For i = 1 To lLen
                aStrs(i) = VTStr(aVars(i))
            Next i
            For i = 1 To lLen - 1
                For j = i + 1 To lLen
                    If (aStrs(i) < aStrs(j)) Xor (ascending <> 0) Then
                        Swap aStrs(i), aStrs(j)
                        Swap aVars(i), aVars(j)
                    End If
                Next j
            Next i
        _memcopy m, m.offset, m.size TO _
            LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.offset
            _MemFree m
        Case LST_LONG
            ReDim aLngs(1 To lLen) As Long
            m = _Mem(aLngs())
        _memcopy LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.offset, m.size _
            To m, m.offset
            For i = 1 To lLen - 1
                For j = i + 1 To lLen
                    If (aLngs(i) < aLngs(j)) Xor (ascending <> 0) Then
                        Swap aLngs(i), aLngs(j)
                    End If
                Next j
            Next i
        _memcopy m, m.offset, m.size TO _
            LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.offset
            _MemFree m
        Case LST_DOUBLE
            ReDim aDbls(1 To lLen) As Double
            m = _Mem(aDbls())
        _memcopy LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.offset, m.size _
            To m, m.offset
            For i = 1 To lLen - 1
                For j = i + 1 To lLen
                    If (aDbls(i) < aDbls(j)) Xor (ascending <> 0) Then
                        Swap aDbls(i), aDbls(j)
                    End If
                Next j
            Next i
        _memcopy m, m.offset, m.size TO _
            LstStore(lstIndex).listMeM, LstStore(lstIndex).listMeM.offset
            _MemFree m
    End Select
End Sub




