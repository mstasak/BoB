'$Debug
$Asserts
Option _Explicit

'$Include: 'list.bi'


'$Include: 'variant.bm'

Sub LstInit
    ReDim LstStore(1 To 10) As LstHolderStruct
    LstMaxUsed = 0
    LstReleased = 0
End Sub

Sub LstTerm
    LstReleaseAll
End Sub

''' free the list from memory, invalidating lstHandle
Sub LstRelease (lstHandle As Long)
    If lstHandle = 0 Then Exit Sub
    Dim lstIndex As Long
    lstIndex = LstStoreIndexOf(lstHandle)
    _Assert lstIndex > 0, "List handle not found"
    LstReleaseAt lstIndex, _TRUE
End Sub

''' free the list from memory, invalidating lstHandle
Sub LstReleaseAt (lsIndex As Long, autoCompact As _Byte)
    If LstStore(lsIndex).listHandle = 0 Then Exit Sub
    'release dependencies from array variant types
    If LstStore(lsIndex).listType = LST_STRING Then
        Dim i As Long
        Dim m As _MEM, elem As Long
        m = _Mem(elem)
        For i = 1 To LstStore(lsIndex).listLength
            _MemCopy LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET + _SIZE_OF_LONG * (i - 1), _SIZE_OF_LONG To m, m.OFFSET
            VTRelease elem
        Next i
        _MemFree m
        _MemFree LstStore(lsIndex).listMeM
    End If


    LstStore(lsIndex).listHandle = 0
    LstStore(lsIndex).listType = LST_NONE
    LstStore(lsIndex).listName = ""
    LstReleased = LstReleased + 1
    If autoCompact _AndAlso LstStore(lsIndex).listAlloc > 10 _AndAlso LstMaxUsed - LstReleased < LstStore(lsIndex).listAlloc * 0.4 Then
        LstCompact LstStore(lsIndex).listAlloc
    End If
End Sub

Sub LstReleaseAll
    Dim i As Long
    For i = 1 To LstMaxUsed
        LstReleaseAt (i), _FALSE
    Next i
    ReDim LstStore(1 To 10) As LstHolderStruct
    LstMaxUsed = 0
    LstReleased = 0
End Sub

Function LstStoreIndexOf& (lstHandle As Long)
    'TODO: consider sorting VStore by handle and using binary search
    Dim i As Long
    For i = 1 To LstMaxUsed
        If LstStore(i).listHandle = lstHandle Then
            LstStoreIndexOf = i
            Exit Function
        End If
    Next i
    LstStoreIndexOf = -1
End Function

Function LstNewStr&
    Dim slotIx As Long
    slotIx = LstCreate
    _Assert slotIx > 0, "List creation failed"
    LstStore(slotIx).listType = LST_STRING
    LstStore(slotIx).listAlloc = 10 'array elements
    LstStore(slotIx).listGrowth = 1.0 'grow 100% when full
    LstStore(slotIx).listLength = 0
    Dim m As _MEM
    m = _MemNew(LstStore(slotIx).listAlloc * _SIZE_OF_LONG)
    LstStore(slotIx).listMeM = m
    LstNewStr = LstStore(slotIx).listHandle
End Function

Function LstCreate
    lstLastHandle = lstLastHandle + 1
    Dim lsIndex As Long
    lsIndex = LstNextLStoreIndex
    LstStore(lsIndex).listHandle = lstLastHandle
    LstStore(lsIndex).listType = LST_NONE
    LstCreate = lsIndex

End Function

Function LstNextLStoreIndex&
    If LstReleased > 0 Then
        LstNextLStoreIndex = LstStoreIndexOf(0)
        LstReleased = LstReleased - 1
        Exit Function
    End If
    Do While LstMaxUsed >= UBound(LstStore)
        ReDim _Preserve LstStore(1 To 2 * UBound(LstStore)) As LstHolderStruct
    Loop
    LstMaxUsed = LstMaxUsed + 1
    LstNextLStoreIndex = LstMaxUsed
End Function

Sub LstAddStr (lHandle As Long, s As String)
    _Assert lHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lHandle)
    LstAddStrAt lsIndex, s
End Sub

Sub LstAddStrAt (lsIndex As Long, s As String)
    _Assert lsIndex > 0, "List handle not found"
    'grow list if needed
    If LstStore(lsIndex).listLength + 1 > LstStore(lsIndex).listAlloc Then
        LstGrowAt (lsIndex)
    End If
    'poke in new value at end
    Dim m As _MEM
    Dim strvar As Long
    strvar = VTNewStr(s)
    m = _Mem(strvar)
    _MemCopy m, m.OFFSET, m.SIZE To LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET + LstStore(lsIndex).listLength * _SIZE_OF_LONG
    _MemFree m
    'update list properties
    LstStore(lsIndex).listLength = LstStore(lsIndex).listLength + 1
End Sub

Sub LstGrowAt (lsindex As Long)
    Dim As Long grow
    grow = _Ceil(LstStore(lsindex).listAlloc * LstStore(lsindex).listGrowth)
    If grow < 1 Then grow = 1
    Dim m As _MEM
    m = _MemNew((LstStore(lsindex).listAlloc + grow) * _SIZE_OF_LONG)
    _MemCopy LstStore(lsindex).listMeM, LstStore(lsindex).listMeM.OFFSET, LstStore(lsindex).listLength * _SIZE_OF_LONG To m, m.OFFSET
    _MemFree LstStore(lsindex).listMeM
    LstStore(lsindex).listMeM = m
    LstStore(lsindex).listAlloc = LstStore(lsindex).listAlloc + grow
End Sub

Sub LstDeleteStr (lHandle As Long, position As Long)
    _Assert lHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lHandle)
    LstDeleteStrAt lsIndex, position, _TRUE
End Sub

Sub LstDeleteStrAt (lsIndex As Long, position As Long, autoCompact As _Byte)
    _Assert lsIndex > 0, "List handle not found"
    If position < 1 Or position > LstStore(lsIndex).listLength Then Exit Sub
    ReDim lvars(1 To LstStore(lsIndex).listAlloc) As Long
    Dim m As _MEM
    m = _Mem(lvars())
    _MemCopy LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET, LstStore(lsIndex).listLength * _SIZE_OF_LONG To m, m.OFFSET
    VTRelease lvars(position)
    Dim i As Long
    For i = position To LstStore(lsIndex).listLength - 1
        lvars(i) = lvars(i + 1)
    Next i
    LstStore(lsIndex).listLength = LstStore(lsIndex).listLength - 1

    If autoCompact Then
        Dim newalloc As Long
        newalloc = LstStore(lsIndex).listAlloc
        Do While LstStore(lsIndex).listLength / (newalloc / (1 + LstStore(lsIndex).listGrowth)) < 0.8
            newalloc = _Ceil((newalloc / (1 + LstStore(lsIndex).listGrowth)) < 0.8)
        Loop
        If newalloc < 10 Then newalloc = 10
        If LstStore(lsIndex).listAlloc <> newalloc Then
            _MemFree LstStore(lsIndex).listMeM
            LstStore(lsIndex).listMeM = _MemNew(newalloc * _SIZE_OF_LONG)
        End If
        _MemCopy m, m.OFFSET, m.SIZE To LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET
    End If
End Sub

Sub LstChangeStr (lHandle As Long, position As Long, newValue As String)
    _Assert lHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lHandle)
    LstChangeStrAt lsIndex, position, newValue
End Sub

Sub LstChangeStrAt (lsIndex As Long, position As Long, newValue As String)
    _Assert lsIndex > 0, "List handle not found"
    If position < 1 Or position > LstStore(lsIndex).listLength Then Exit Sub 'position does not exist
    Dim strvar As Long, m As _MEM
    m = _Mem(strvar)
    _MemCopy LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET + (position - 1) * _SIZE_OF_LONG, _SIZE_OF_LONG To m, m.OFFSET
    VTRelease (strvar)
    strvar = VTNewStr(newValue)
    _MemCopy m, m.OFFSET, _SIZE_OF_LONG To LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET + (position - 1) * _SIZE_OF_LONG
    _MemFree m
End Sub

Sub LstInsertStr (lHandle As Long, position As Long, s As String)
    _Assert lHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lHandle)
    LstInsertStrAt lsIndex, position, s
End Sub

Sub LstInsertStrAt (lsIndex As Long, position As Long, s As String)
    _Assert lsIndex > 0, "List handle not found"
    'grow list if needed
    If LstStore(lsIndex).listLength + 1 > LstStore(lsIndex).listAlloc Then
        LstGrowAt (lsIndex)
    End If
    'insert new value at position
    Dim m As _MEM
    Dim As Long strvar, lLen
    lLen = LstStore(lsIndex).listLength
    strvar = VTNewStr(s)
    ReDim tail(position To lLen + 1) As Long
    tail(position) = strvar
    m = _Mem(tail())
    _memcopy lststore(lsindex).listmem,lststore(lsindex).listmem.offset + (position-1) * _size_of_long, _
             (lLen - position + 1) * _size_of_long to m,m.offset + _size_of_long
    _MemCopy m, m.OFFSET, m.SIZE To LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET + (position - 1) * _SIZE_OF_LONG
    _MemFree m
    'update list properties
    LstStore(lsIndex).listLength = LstStore(lsIndex).listLength + 1
End Sub

Function LstStrAt$ (lHandle As Long, position As Long)
    _Assert lHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lHandle)
    LstStrAt = LstStrAtAtIndex(lsIndex, position)
End Function

Function LstStrAtAtIndex$ (lsIndex As Long, position As Long)
    _Assert lsIndex > 0, "List handle not found"
    If position < 1 Or position > LstStore(lsIndex).listLength Then
        LstStrAtAtIndex = ""
        Exit Function
    End If
    Dim strvar As Long
    Dim m As _MEM
    m = _Mem(strvar)
    _MemCopy LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.OFFSET + (position - 1) * _SIZE_OF_LONG, _SIZE_OF_LONG To m, m.OFFSET
    _MemFree m
    LstStrAtAtIndex = VTStr(strvar)
End Function

Function LstCount& (lHandle As Long)
    _Assert lHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lHandle)
    LstCount = LstCountAt(lsIndex)
End Function

Function LstCountAt& (lsIndex As Long)
    _Assert lsIndex > 0, "List handle not found"
    LstCountAt = LstStore(lsIndex).listLength
End Function


''' Redimension list store if <40% full (due to element deletions)
Sub LstCompact (newUB As Long) 'size in Long elements
    _Assert newUB > 10 And newUB * 0.8 > LstMaxUsed - LstReleased, "LstCompact upper bound too low."
    Dim As Long i, j, newmax
    If LstReleased > 0 Then
        j = 2
        For i = 1 To LstMaxUsed
            If LstStore(i).listHandle = 0 Then
                If j <= i Then j = i + 1
                Do While LstStore(j).listHandle = 0 And j < LstMaxUsed
                    j = j + 1
                Loop
                If j <= LstMaxUsed Then
                    LstStore(i) = LstStore(j)
                    LstStore(j).listHandle = 0
                    LstStore(j).listType = LST_NONE
                    LstStore(j).listName = ""
                    If LstStore(i).listHandle > 0 Then newmax = i
                End If
            Else
                newmax = i
            End If
        Next i
        LstMaxUsed = newmax
        LstReleased = 0
    End If
    ReDim _Preserve LstStore(1 To newUB) As LstHolderStruct
End Sub

''' Return a string representation of the list, such as:  ListOfString["apples", "oranges"] or ListOfLong[1,2,4,8]
Function LstToStr$ (lstHandle As Long)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lstHandle)
    LstToStr = LstToStrAt(lsIndex)
End Function

Function LstToStrAt$ (lsIndex As Long)
    Dim rslt As String
    _Assert lsIndex > 0, "List handle not found"
    Dim lst As LstHolderStruct
    lst = LstStore(lsIndex)
    rslt = "String List"
    If lst.listName <> "" Then rslt = rslt + " " + lst.listName
    Dim i As Long, sep As String
    sep = "["
    For i = 1 To lst.listLength
        rslt = rslt + sep + _CHR_QUOTE + LstStrAtAtIndex(lsIndex, i) + _CHR_QUOTE
        sep = ", "
    Next i
    rslt = rslt + "]"

    LstToStrAt = rslt
End Function

Sub LstDump
    Dim i As Long
    Dim listCount As Long
    Print "List Store"
    listCount = 0
    Print String$(80, "")
    Print String$(80, "âŒ ")
    For i = 1 To LstMaxUsed
        If LstStore(i).listType = LST_STRING Then
            Print i, lstGetNameAt(i), LstToStrAt(i)
            listCount = listCount + 1
        End If
    Next i
    Print String$(80, "-")
    Print listCount; " list(s)."
    Print
End Sub

Sub LstSetName (lstHandle As Long, newName As String)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lstHandle)
    LstSetNameAt lsIndex, newName
End Sub

Sub LstSetNameAt (lstIndex As Long, newName As String)
    _Assert lstIndex > 0, "List handle not found"
    LstStore(lstIndex).listName = newName
End Sub

Function lstGetName$ (lstHandle As Long)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lstHandle)
    lstGetName = lstGetNameAt(lsIndex)
End Function

Function lstGetNameAt$ (lstIndex As Long)
    _Assert lstIndex > 0, "List handle not found"
    lstGetNameAt = LstStore(lstIndex).listName
End Function

Sub LstSort (lstHandle As Long, ascending As _Byte)
    _Assert lstHandle > 0, "Invalid list handle arguement"
    Dim lsIndex As Long
    lsIndex = LstStoreIndexOf(lstHandle)
    LstSortAt lsIndex, ascending
End Sub

Sub LstSortAt (lsIndex As Long, ascending As _Byte)
    _Assert lsIndex > 0, "List handle not found"
    Dim lLen As Long
    lLen = LstStore(lsIndex).listLength
    ReDim aVars(1 To lLen) As Long
    ReDim aStrs(1 To lLen) As String
    Dim m As _MEM
    m = _Mem(aVars())
    _memcopy LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.offset, m.size _
        To m, m.offset
    Dim As Long i, j
    For i = 1 To lLen
        aStrs(i) = VTStr(aVars(i))
    Next i
    For i = 1 To lLen - 1
        For j = i + 1 To lLen
            If (aStrs(i) < aStrs(j)) Xor (ascending <> 0) Then
                Swap aStrs(i), aStrs(j)
                Swap aVars(i), aVars(j)
            End If
        Next j
    Next i
    _memcopy m, m.offset, m.size TO _
        LstStore(lsIndex).listMeM, LstStore(lsIndex).listMeM.offset
    _MemFree m
End Sub

